<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Legendary</title>
<script>
"use strict";

// Generic JS definitions
function RNG(seed) {
  this.m = 0x100000000;
  this.a = 1103515245;
  this.c = 12345;
  this.state = seed === undefined ? Math.floor(Math.random() * (this.m-1)) : seed;
}
RNG.prototype.nextInt = function() {
  this.state = (this.a * this.state + this.c) % this.m;
  return this.state;
}
RNG.prototype.nextFloat = function() {
  return this.nextInt() / (this.m - 1);
}
RNG.prototype.nextRange = function(start, end) {
  var rangeSize = end - start;
  var randomUnder1 = this.nextInt() / this.m;
  return start + Math.floor(randomUnder1 * rangeSize);
}
RNG.prototype.choice = function(array) {
  return array[this.nextRange(0, array.length)];
}
var shuffleArray = function(a, r) {
    var len = a.length;
    var i = len;
    while (i--) {
	var p = r.nextRange(0,len);
	var t = a[i];
	a[i] = a[p];
	a[p] = t;
    }
};
function isNumber(x) {
  return !isNaN(x - 0) && x != null;
}

// Game primitives: Cards
var Card = function(t) {
  this.cardType = t;
}
Card.prototype = {
  get cost() { return this.printedCost; },
  get attack() { return this.printedAttack; },
  get recruit() { return this.printedRecruit; },
  get attackCost() { return this.printedAttackCost; },
  get defense() { return this.printedDefense; },
  get vp() { return this.printedVP; },
  isPlayable: function () { return this.playable; },
  isVillain: function () { return this.cardType === "VILLAIN"; },
  isColor: function(c) { return (this.color & c) !== 0; },
  isTeam: function(t) { return this.team === t; },
  toString: function () { return "AHA"; },
}
var Color = {
  RED:1,
  YELLOW:2,
  BLACK:4,
  BLUE:8,
  GREEN:16,
  GRAY:32,
};
function makeHeroCard(hero, name, cost, recruit, attack, color, team, effects) {
  var c = new Card("HERO");
  c.printedCost = cost;
  c.printedRecruit = recruit;
  c.printedAttack = attack;
  c.cardName = name;
  c.heroName = hero;
  c.color = color || Color.GRAY;
  c.team = team;
  c.playable = true;
  c.effects = typeof effects === "function" ? [ effects ] : effects;
  return c;
}
function makeVillainCard(group, name, defense, vp, abilities) {
  var c = new Card("VILLAIN");
  c.printedDefense = defense;
  c.printedVP = vp;
  c.cardName = name;
  c.villainGroup = group;
  c.fightable = true;
  if (abilities) for (var i in abilities) c[i] = abilities[i];
  return c;
}
function makeMastermindCard(name, defense, vp, leads, strike, tactics, abilities) {
  var c = new Card("MASTERMIND");
  c.printedDefense = defense;
  c.printedVP = vp;
  c.cardName = name;
  c.leads = leads;
  c.fightable = true;
  c.strike = strike;
  c.tacticsTemplates = tactics.map(function (e) {
    var c = new Card("TACTICS");
    c.printedVP = vp;
    c.printedDefense = defense;
    c.cardName = e[0];
    c.fight = e[1];
    return c;
  });
  if (abilities) for (var i in abilities) c[i] = abilities[i];
  return c;
}
function makeBystanderCard(name, rescue) {
  var c = new Card("BYSTANDER");
  c.printedVP = 1;
  c.cardName = name;
  c.rescue = rescue;
  return c;
}
function makeHenchmenCard(name, defense, abilities) {
  return makeVillainCard(undefined, name, defense, 1, abilities);
}
function makeCardInstance(c) {
  var c = Object.create(c);
  c.id = (c.cardName || c.cardType) + '@' + gameState.nextId++;
  c.ctype = "I";
  return c;
}
function makeCardInPlay(c, where, bottom) {
  if (c.ctype !== 'I') throw TypeError("need card instance");
  var r = Object.create(c);
  r.instance = c;
  r.ctype = "P";
  r.location = where;
  if (bottom) where._putBottom(r);
  else where._put(r);
}
function makeCardCopy(c, where) {
  if (c.ctype !== 'P') throw TypeError("need card in play");
  var i = r.copyOf || c.instance;
  var r = makeCardInPlay(i, where);
  r.copyOf = i;
  delete r.instance;
  // Artifact specials - choose which ability -- embed in artifact play effect
  return r;
}
function makeCardCopyPaste(c, p) {
  if (c.ctype !== 'P') throw TypeError("need card in play");
  if (p.ctype !== 'P') throw TypeError("need card in play");
  var i = c.copyOf || c.instance;
  var r = Object.create(i);
  r.instance = p.instance;
  r.ctype = "P";
  r.location = p.location;
  r.copyOf = i;
  r.color = r.color | p.color;
  // TODO: copy other tmp state (MOoT?)
  r.location.deck[r.location.deck.indexOf(p)] = r;
  // Return to stack effects - trigger replace move to sidekick/new recruit stacks
}
function moveCard(c, where, bottom) {
  if (c.ctype !== 'P') throw TypeError("need card in play");
  c.location.remove(c);
  if (!c.instance) return;
  //TODO retain some properties of cards when moved to played?
  //TODO verify no attached cards (only cards in city decks can have those - maybe HQ)
  makeCardInPlay(c.instance, where, bottom);
}
function moveAll(from, to, bottom) {
  while (from.count) moveCard(from.top, to, bottom);
}
// Game primitives: Decks
var Deck = function(name, faceup) {
  this.name = name;
  this.deck = [];
  this.attached = [];
  this.faceup = faceup === true;
  Deck.prototype.deckList.push(this);
}
Deck.prototype = {
  get count() { return this.deck.length; },
  addNewCard: function(c, n) { for (var i = 0; i < (n || 1); i++) makeCardInPlay(makeCardInstance(c), this); },
  _put: function(c) { this.deck.push(c); },
  _putBottom: function(c) { this.deck.unshift(c); },
  shuffle: function() { shuffleArray(this.deck, gameState.gameRand); },
  get top() { return this.deck[0]; },
  get bottom() { return this.deck[this.deck.length - 1]; },
  remove: function(c) { var p = this.deck.indexOf(c); if (p >= 0) this.deck.splice(p, 1); return p >= 0; },
  deckList: [],
}

// Card definitions
var u = undefined;
var sa = makeHeroCard('HERO', 'SHIELDAGENT',   0, 1, u);
var sb = makeHeroCard('HERO', 'SHIELDTROOPER', 0, u, 1);
var sc = makeHeroCard('MARIA HILL', 'SHIELDOFFICER', 3, 2, u);
var sd = makeHenchmenCard('HAND NINJAS', 3, { fight: function(ev) { addRecruitEvent(ev, 1); } });
var se = makeHenchmenCard('SAVAGE LAND MUTATES', 4, { fight: function(ev) { addEndDrawMod(1); } });
var sf = makeBystanderCard();
var sg = new Card("SCHEME TWIST");
var dh = new Card("MASTER STRIKE");

var di = makeMastermindCard("DR. DOOM", 9, 5, "DOOMBOT LEGION",
  function (ev) {
    //Each player with exactly 6 cards in hand reveals a Tech Hero or puts 2 cards from their hand on top of their deck.
    if (playerState.hand.count === 6) { // TODO: multiplayer
      revealOrEv(ev, Color.BLACK, function (ev) {
        selectCardEv(ev, playerState.hand, function (ev) { moveCardEv(ev, ev.selected, playerState.deck); });
        selectCardEv(ev, playerState.hand, function (ev) { moveCardEv(ev, ev.selected, playerState.deck); });
      });
    }
  },
  [
    [ "Dark Technology", function (ev) { // You may recruit a Tech or Ranged Hero from the HQ for free.
      selectCardEv(ev, HQCards().filter(isColor(Color.BLACK | Color.BLUE)), function (ev) { gainEv(ev, ev.selected); });
    } ],
    [ "Monarch's Decree", function (ev) { // Choose one: each other player draws a card or each other player discards a card.
      chooseOneEv(ev, "Each other player draws a card", function (ev) {
        eachOtherPlayerVM().forEach(function(p) { pickDiscardEv(ev, p); });
      }, "Each other player discards a card", function (ev) {
        eachOtherPlayerVM().forEach(function(p) { drawEv(ev, p); });
      });
    } ],
    [ "Secrets of Time Travel", function (ev) { // Take another turn after this one.
      gameState.extraTurn = true; // TODO: multiplayer
    } ],
    [ "Treasures of Latveria", function (ev) { // When you draw a new hand of cards at the end of this turn, draw three extra cards.
      addEndDrawMod(3);
    } ],
  ]
);
var herocards = [
{
  name:'Thor',
  c1:makeHeroCard('THOR', 'ODINSON', 3, 2, u, Color.GREEN, 'AVENGERS', function (ev) { if (superPower(ev, Color.GREEN)) addRecruitEvent(ev, 2); }),
  c2:makeHeroCard('THOR', 'SURGE OF POWER', 4, 2, 0, Color.BLUE, 'AVENGERS', function (ev) { if (turnState.totalRecruit >= 8) addAttackEvent(ev, 3); }),
  uc:makeHeroCard('THOR', 'CALL LIGHTNING', 6, u, 3, Color.BLUE, 'AVENGERS', function (ev) { if (superPower(ev, Color.BLUE)) addAttackEvent(ev, 3); }),
  ra:makeHeroCard('THOR', 'GOD OF THUNDER', 8, 5, 0, Color.BLUE, 'AVENGERS', function (ev) { turnState.attackWithRecruit = true; }),
},
{
  name:'Wolverine',
  team:'X-Men',
  c1:makeHeroCard('Wolverine', 'Healing Factor', 3, u, 2, Color.YELLOW, 'X-Men', function (ev) {
    selectCardOptEv(ev, handOrDiscard().filter(isWound), function (ev) { drawEv(ev); KOEv(ev, ev.selected); });
  }),
  c2:makeHeroCard('Wolverine', 'Keen Senses', 2, u, 1, Color.YELLOW, 'X-Men', function (ev) { if (superPower(ev, Color.YELLOW)) drawEv(ev); }),
  uc:makeHeroCard('Wolverine', 'Frenzied Slashing', 5, u, 2, Color.YELLOW, 'X-Men', function (ev) { if (superPower(ev, Color.YELLOW)) drawEv(ev, 2);}),
  ra:makeHeroCard('Wolverine', 'Berserker Rage', 8, u, 0, Color.YELLOW, 'X-Men', [ function (ev) { drawEv(ev, 3); }, function (ev) { addAttackEvent(ev, turnState.cardsDrawn); } ]),
},
];

// State init
var eventQueue = [];
var turnState = undefined;
var playerState = {
  deck: new Deck('DECK0'),
  discard: new Deck('DISCARD0', true),
  hand: new Deck('HAND0', true),
  victory: new Deck('VICTORY0', true),
};
playerState.deck.owner = playerState.discard.owner = playerState.hand.owner = playerState.victory.owner = playerState;
var gameState = {
  type: "STATE",
  nextId: 0,
  gameRand: new RNG(),
  playArea: new Deck('PLAYAREA'),
  escaped: new Deck('ESCAPED'),
  villaindeck: new Deck('VILLAIN'),
  ko: new Deck('KO', true),
  herodeck: new Deck('HERO'),
  officer: new Deck('SHIELDOFFICER', true),
  hq: [
    new Deck("HQ1", true),
    new Deck("HQ2", true),
    new Deck("HQ3", true),
    new Deck("HQ4", true),
    new Deck("HQ5", true),
  ],
  city: [
    new Deck("BRIDGE", true),
    new Deck("ROOFTOPS", true),
    new Deck("STREETS", true),
    new Deck("BANK", true),
    new Deck("SEWERS", true),
  ],
  triggers: [
    { // Replace HQ cards.
      event: "MOVECARD",
      match: function (ev) { return ev.from.isHQ; },
      after: function (ev) { if (gameState.herodeck.count) moveCardEv(ev, gameState.herodeck.top, ev.parent.from); },
    },
    { // Shift city on entry.
      event: "MOVECARD",
      match: function (ev) { return ev.to.isCity && ev.to.count; },
      before: function (ev) { var to = ev.parent.to; if (to.next) moveCardEv(ev, to.top, to.next); else pushEvents({ type: "ESCAPE", what: to.top, parent: ev }); },
    },
  ],
  endDrawAmount: 6,
  players: [ playerState ],
  advancedSolo: true,
};
gameState.cityEntry = gameState.city[4];

for (var i = 0; i < 5; i++) {
  gameState.hq[i].below = gameState.city[i];
  gameState.city[i].above = gameState.hq[i];
  gameState.city[i].isCity = true;
  gameState.hq[i].isHQ = true;
  if (i) gameState.city[i].next = gameState.city[i - 1];
}

// Init starting decks
playerState.deck.addNewCard(sa, 8);
playerState.deck.addNewCard(sb, 4);
playerState.deck.shuffle();
// Init hero deck and populate initial HQ
for (var i = 0; i < herocards.length; i++) {
  gameState.herodeck.addNewCard(herocards[i].c1, 5);
  gameState.herodeck.addNewCard(herocards[i].c2, 5);
  gameState.herodeck.addNewCard(herocards[i].uc, 3);
  gameState.herodeck.addNewCard(herocards[i].ra);
}
gameState.herodeck.shuffle();
for (var i = 0; i < gameState.hq.length; i++) moveCard(gameState.herodeck.top, gameState.hq[i]);
// Init villain deck
gameState.villaindeck.addNewCard(sd, 10);
gameState.villaindeck.addNewCard(se, 10);
gameState.villaindeck.shuffle();
// Init Mastermind TODO
// Init Scheme TODO
// Init auxiliary decks
gameState.officer.addNewCard(sc, 30);
// Draw initial hand
for (var i = 0; i < gameState.endDrawAmount; i++) {
  moveCard(playerState.deck.top, playerState.hand);
}


// Card effects functions
function isWound(c) { return c.cardType === "WOUND"; }
function isColor(col) { return function (c) { return c.isColor(col); }; }
function isTeam(team) { return function (c) { return c.isTeam(team); }; }

function othersPlayed(ev) { return turnState.cardsPlayed.filter(function (c) { return c.id != ev.source.id; }); } // TODO: find source upstream
function handOrDiscard() { return playerState.hand.deck.concat(playerState.discard.deck); }
function HQCards() { return gameState.hq.map(function (e) { return e.top; }).filter(function (e) { return e; }); }
function eachOtherPlayer() { retuen gameState.filter(function (e) { return e !== playerState; }); }
function eachOtherPlayerVM() { return gameState.advancedSolo ? gameState.players : eachOtherPlayer(); }

function superPower(ev, w) { return othersPlayed(ev).some(isNumber(w) ? isColor(w) : isTeam(w)); }
function addEndDrawMod(a) { turnState.endDrawMod = (turnState.endDrawMod || 0) + a; }
function setEndDrawAmount(a) { turnState.endDrawAmount = a; }

// Game engine functions
function pushEvents() {
  var newev = [];
  for (var i = 0; i < arguments.length; i++) {
    newev = newev.concat(addTriggers(arguments[i]));
  }
  eventQueue = newev.concat(eventQueue);
}
function canRecruit(c) {
  return turnState.recruit >= c.cost;
}
function canFight(c) {
  var a = turnState.attack;
  if (c.bribe || turnState.attackWithRecruit) a += turnState.recruit;
  return a >= c.defense;
}
function getActions(ev) {
  var p = playerState.hand.deck.filter(function(e) { return e.isPlayable(); }).map(function (e) { return {
    type: "PLAY",
    what: e,
    parent: ev,
  }; });
  p = p.concat(gameState.hq.filter(function(d) { return d.count && canRecruit(d.top); }).map(function (d) { return {
    type: "RECRUIT",
    what: d.top,
    parent: ev,
  }; }));
  p = p.concat(gameState.city.filter(function(d) { return d.count && canFight(d.top); }).map(function (d) { return {
    type: "FIGHT",
    what: d.top,
    parent: ev,
  }; }));
  if (gameState.officer.count && canRecruit(gameState.officer.top)) p = p.concat({
    type: "RECRUIT",
    what: gameState.officer.top,
    parent: ev,
  });
  p = p.concat({type: "ENDOFTURN", parent:ev});
  return p;
}

function addAttackEvent(ev, c) { pushEvents({ type: "ADDATTACK", source: ev.what, parent: ev, amount: c }); }
function addRecruitEvent(ev, c) { pushEvents({ type: "ADDRECRUIT", source: ev.what, parent: ev, amount: c }); }
function moveCardEv(ev, what, where, bottom) {
  pushEvents({ type:"MOVECARD", what:what, from:what.location, to:where, bottom:bottom, parent:ev }); 
}
function gainEv(ev, card, who) { pushEvents({type:"GAIN", what:card, who:who || playerState, parent: ev}); }
function discardEv(ev, card) { pushEvents({ type: "DISCARD", parent: ev, what:card }); }
function drawEv(ev, amount, who) { pushEvents({ type: "DRAW", who: who || playerState, amount: amount || 1, parent: ev }); }
function KOEv(ev, card) { pushEvents({ type:"KO", parent: ev, what:card }); }
function selectCardEv(ev, cards, effect, who) { }
function selectCardOptEv(ev, cards, effect1, effect0, who) { }
//function revealOrEv(ev, cond, effect, who?) { }
//function chooseOneEv(ev) { }
function pickDiscardEv(ev, who, agent) {
  who = who || playerState;
  agent = agent || who;
  selectCardEv(ev, who.hand, function (ev) { discardEv(ev, ev.selected); }, agent);
}


function playCard(ev) {
  // PAY PLAYCOST (discard or top deck 1-3 cards)
  moveCardEv(ev, ev.what, gameState.playArea);
  turnState.cardsPlayed.push(ev.what);
  for (var i = 0; ev.what.effects && i < ev.what.effects.length; i++) {
    pushEvents( { type: "EFFECT", source: ev.what, parent: ev, func: ev.what.effects[i] } );
  }
  if (ev.what.attack) addAttackEvent(ev, ev.what.attack);
  if (ev.what.recruit) addRecruitEvent(ev, ev.what.recruit);
}
function buyCard(ev) {
  // TODO: other pay options
  turnState.recruit -= ev.what.cost;
  gainEv(ev, ev.what);
}
function gainCard(ev) {
  moveCardEv(ev, ev.what, ev.who.discard);
}
function cleanUp(ev) {
  moveAll(playerState.hand, playerState.discard);
  moveAll(gameState.playArea, playerState.discard);
  var drawAmount = (turnState.endDrawAmount || gameState.endDrawAmount) + (turnState.endDrawMod || 0);
  drawEv(ev, drawAmount);
}
function drawOne(ev) {
  if (!ev.who.deck.count && ev.who.discard.count) {
    pushEvents({type: "RESHUFFLE", parent:ev}, ev); // TODO: Make global state trigger?
  } else if (ev.who.deck.count) {
    moveCardEv(ev, ev.who.deck.top, ev.who.hand);
    turnState.cardsDrawn++;
  }
}
function reshufflePlayerDeck() {
  moveAll(playerState.discard, playerState.deck);
  playerState.deck.shuffle();
}
function villainDraw(ev) {
  var c = gameState.villaindeck.top;
  if (c.isVillain()) {
    if (c.ambush) pushEvents({ type: "EFFECT", source: c, parent: ev, func: c.ambush });
    moveCardEv(ev, c, gameState.cityEntry);
  } else {
    console.log("dont know what to do with", c);
  }
}
function villainEscape(ev) {
  // TODO order of move and tigger escape?
  // TODO bystanders
  if (ev.what.escape) pushEvents({ type: "EFFECT", source: ev.what, parent: ev, func: ev.what.escape });
  moveCardEv(ev, ev.what, gameState.escaped);
}
function villainFight(ev) {
  // TODO Deal with extra costs
  var c = ev.what;
  turnState.attack -= c.defense; // Use attack first
  if (turnState.attack < 0) { // Asume bribe
    // TODO Ask for spilt (optional)
    turnState.recruit += turnState.attack;
    turnState.attack = 0;
  }
  pushEvents({ type: "DEFEAT", what: c, parent: ev });
}
function villainDefeat(ev) {
  var c = ev.what;
  if (c.fight) pushEvents({ type: "EFFECT", source: c, parent: ev, func: c.fight });
  moveCardEv(ev, c, playerState.victory);
}
function findTriggers(ev) {
  var tempTriggers = [];
  if (turnState.triggers) tempTriggers.concat(turnState.triggers);
  if (!tempTriggers.length) return gameState.triggers;
  return gameState.triggers.concat(tempTriggers);
}
function addTriggers(ev) {
  // TODO: more dynamic events (add generic { type:"TRIGGER", what:ev.type, when:"BEFORE" }), harder for replacement and steteful before/after triggers
  // TODO: add state for before/after triggers
  var triggers = findTriggers(ev).filter(function(t){return t.event === ev.type && t.match(ev)});
  var newev = [];
  triggers.forEach(function(t) {
    if (t.before)
      newev.push({type:"EFFECT", func:t.before, /*state:ts[i],*/ parent:ev});
  });
  newev.push(ev);
  triggers.forEach(function(t) {
    if (t.after)
      newev.push({type:"EFFECT", func:t.after, /*state:ts[i],*/ parent:ev});
  });
  triggers.forEach(function(t) {
    if (t.replace)
      newev = [{type:"EFFECT", func:t.replace, what:newev, parent:ev }];
  });
  return newev;
}
function playGame() {
do {
  var ev = eventQueue.shift() || {
    type:"TURN",
    recruit: 0,
    attack: 0,
    totalRecruit: 0,
    cardsPlayed: [],
    cardsDrawn: 0,
    parent:gameState
  };
  console.log(">>> " + ev.type, ev);
  ({
    "TURN": function() {
      turnState = ev;
      pushEvents({type:"VILLAINDRAW",parent:ev},{type:"ACTIONS",parent:ev},{type:"CLEANUP",parent:ev});
    },
    "ACTIONS": function () {
      if (!ev.endofturn) {
        pushEvents({type:"EVENTSELECT",parent:ev,options:getActions(ev),ui:true},ev);
      }
    },
    "ENDOFTURN": function () { ev.parent.endofturn = true; },
    "CLEANUP": cleanUp,
    "PLAY": playCard,
    "RECRUIT": buyCard,
    "GAIN": gainCard,
    "DRAW": function () { for (var i = 0; i < ev.amount; i++) pushEvents({type:"DRAWONE", who:ev.who, parent:ev.parent}); },
    "DRAWONE": drawOne,
    "RESHUFFLE": reshufflePlayerDeck,
    "ADDATTACK": function () { turnState.attack += ev.amount; },
    "ADDRECRUIT": function () { turnState.recruit += ev.amount; turnState.totalRecruit += ev.amount; },
    "MOVECARD": function () { moveCard(ev.what, ev.to, ev.bottom); },
    "EFFECT": ev.func,
    "VILLAINDRAW": villainDraw,
    "ESCAPE": villainEscape,
    "FIGHT": villainFight,
    "DEFEAT": villainDefeat,
    "DISCARD": function () { moveCardEv(ev, ev.what, ev.what.location.owner.discard); },
    "KO": function () { moveCardEv(ev, ev.what, gameState.ko); },
  }[ev.type] || function(){
    console.log("Unknown event type", ev);
  })(ev);
} while (!eventQueue.length || !eventQueue[0].ui);
}

// GUI
function makeDisplayCard(c) {
  return c.id;
}
function displayDecks() {
  var divs = document.getElementsByClassName("deck");
  var divByName = {};
  for (var i = 0; i < divs.length; i++) {
    divByName[divs[i].getAttribute("data-deck")] = divs[i];
  }
  var list = Deck.prototype.deckList;
  for (var i = 0; i < list.length; i++) {
    var deck = list[i];
    var div = divByName[deck.name];
    if (!div) continue;
    div.innerHTML = deck.name + ': ' + deck.deck.map(makeDisplayCard).join(' ');
  }
}
function displayGame() {
  displayDecks();
  document.getElementById("recruit").innerHTML = turnState.recruit;
  document.getElementById("attack").innerHTML = turnState.attack;
}
function init() {
  var count = 0;
  function makeAction() {
    count++;
    var ev = eventQueue.shift();
    ({
      "EVENTSELECT": function () { pushEvents(ev.options[0]); },
    }[ev.type] || function () {
      conosle.log("Unknown UI event type", ev);
    })();
    playGame();
    displayGame();
    if (count < 100) setTimeout(makeAction, 200);  
  }
  playGame();
  displayGame();
  setTimeout(makeAction, 1000);
}
document.addEventListener('DOMContentLoaded', init, false);
/*
GUI selectable options

ENGINE:
Scheme
Scheme Twists

Mastermind
Master Strikes

Bystanders

Wounds
Other villains
*/

</script>
</head>
<body>
Recruit: <span id="recruit"></span>
Attack: <span id="attack"></span>
<div class="deck" data-deck="PLAYAREA"></div>
<hr>
<div class="deck" data-deck="HAND0"></div>
<div class="deck" data-deck="DECK0"></div>
<div class="deck" data-deck="DISCARD0" data-onlytop="1"></div>
<div class="deck" data-deck="VICTORY0" data-onlytop="1"></div>
<hr>
<div class="deck" data-deck="SHIELDOFFICER" data-onlytop="1"></div>
<div class="deck" data-deck="HQ1"></div>
<div class="deck" data-deck="HQ2"></div>
<div class="deck" data-deck="HQ3"></div>
<div class="deck" data-deck="HQ4"></div>
<div class="deck" data-deck="HQ5"></div>
<div class="deck" data-deck="VILLAIN"></div>
<div class="deck" data-deck="SEWERS"></div>
<div class="deck" data-deck="BANK"></div>
<div class="deck" data-deck="STREETS"></div>
<div class="deck" data-deck="ROOFTOPS"></div>
<div class="deck" data-deck="BRIDGE"></div>
<div class="deck" data-deck="ESCAPED"></div>
</body>
</html>
